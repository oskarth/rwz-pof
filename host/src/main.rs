// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use k256::ecdsa::signature::Signer;
use k256::ecdsa::signature::Verifier;
use k256::ecdsa::{Signature, SigningKey, VerifyingKey};
use k256::SecretKey;
use methods::{RWZ_POF_GUEST_ELF, RWZ_POF_GUEST_ID};
use rand_core::OsRng;
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct DealInfo {
    amount: u64,
    deal_id: String,
    buyer: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct SignedMessage {
    pubkey: Vec<u8>,
    message: DealInfo,
    signature: Vec<u8>,
}

fn create_signed_message(
    signing_key: &SigningKey,
    amount: u64,
    deal_id: String,
    buyer: String,
) -> SignedMessage {
    let deal_info = DealInfo {
        amount,
        deal_id,
        buyer,
    };

    // Serialize the message to sign
    let message_bytes = bincode::serialize(&deal_info).unwrap();

    // Sign the message with explicit type
    let signature: k256::ecdsa::Signature = signing_key.sign(&message_bytes);

    // Get the public key
    let verifying_key = VerifyingKey::from(signing_key);

    SignedMessage {
        pubkey: verifying_key.to_sec1_bytes().to_vec(),
        message: deal_info,
        signature: signature.to_bytes().to_vec(),
    }
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // Generate keys for our two lending banks
    let lb1_key = SigningKey::random(&mut OsRng);
    let lb2_key = SigningKey::random(&mut OsRng);

    // Create signed messages for a deal requiring 60 total
    let lb1_signed = create_signed_message(
        &lb1_key,
        50, // LB1 provides 50
        "DEAL123".to_string(),
        "buyer123".to_string(),
    );

    let lb2_signed = create_signed_message(
        &lb2_key,
        30, // LB2 provides 30
        "DEAL123".to_string(),
        "buyer123".to_string(),
    );

    let proof_amount = 60u64; // We want to prove we have at least 60

    // Create executor environment with our inputs
    let env = ExecutorEnv::builder()
        .write(&lb1_signed)
        .unwrap()
        .write(&lb2_signed)
        .unwrap()
        .write(&proof_amount)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Generate the proof
    println!("Starting proof generation...");
    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, RWZ_POF_GUEST_ELF).unwrap();
    let receipt = prove_info.receipt;

    // Read the journal outputs - just the deal info and proved amount
    let (deal_info, verified_amount): (DealInfo, u64) = receipt.journal.decode().unwrap();

    println!("Proof generated successfully!");
    println!("Verified deal info: {:?}", deal_info);
    println!("Verified amount: {}", verified_amount);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(RWZ_POF_GUEST_ID).unwrap();
    println!("Receipt verification successful!");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_signature_creation_and_verification() {
        // Generate a test key
        let signing_key = SigningKey::random(&mut OsRng);

        // Create a signed message
        let signed_msg = create_signed_message(
            &signing_key,
            500,
            "DEAL001".to_string(),
            "buyer1".to_string(),
        );

        // Verify the signature
        let message_bytes = bincode::serialize(&signed_msg.message).unwrap();
        let signature = Signature::from_slice(&signed_msg.signature).unwrap();
        let verifying_key = VerifyingKey::from_sec1_bytes(&signed_msg.pubkey).unwrap();

        // This will panic if verification fails
        verifying_key.verify(&message_bytes, &signature).unwrap();
    }

    #[test]
    fn test_invalid_signature_fails() {
        // Generate two different keys
        let signing_key = SigningKey::random(&mut OsRng);
        let wrong_key = SigningKey::random(&mut OsRng);

        // Create a signed message with first key
        let signed_msg = create_signed_message(
            &signing_key,
            500,
            "DEAL001".to_string(),
            "buyer1".to_string(),
        );

        // Try to verify with wrong key
        let message_bytes = bincode::serialize(&signed_msg.message).unwrap();
        let signature = Signature::from_slice(&signed_msg.signature).unwrap();
        let wrong_verifying_key = VerifyingKey::from(&wrong_key);

        // This should fail
        assert!(wrong_verifying_key
            .verify(&message_bytes, &signature)
            .is_err());
    }
}
